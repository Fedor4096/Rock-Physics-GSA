# Rock-Physics-GSA

Technical implementation of the Generalized Singular Approximation (GSA) method for the case of a two-component rock.

<h2>Краткий список выполненных работ</h2>
<ul>
  <li>Анализ основной формулы GSA и её приведение к виду для двухкомпонентных горных пород</li>
  <li>Декомпозиция процесса расчёта по методу GSA и качественный анализ времени вычислений каждого из этапов с целью выделения наиболее проблемных шагов</li>
  <li>Планирование схемы будущих вычислений с учётом проблемных этапов, выявленных в предыдущем пункте</li>
  <li>Апробация полученных результатов на основе референсных табличных данных</li>
  <li>Оценка доступных технологий для сокращения времени расчёта как для всей программы в целом, так и для наиболее ресурсоёмких шагов</li>
  <li>Адаптирование кода для использования JIT-компиляции: изменение ряда языковых конструкций и декомпозиция уже готовых функций с целью инкапсуляции JIT-исполняемой логики</li>
</ul>

<h2>Теоретическая часть</h2>
В рамках модели GSA горная порода аппроксимируется набором эллептических включений. <br><br>
Каждая компонента горной породы соответсвует группе включений с фиксированными параметрами:
<ul>
  <li>аспектным отношением для осей эллепсоида</li>
  <li>ориентацией в моделируемом объёме</li>
  <li>тензором упругости</li>
</ul><br>
Также в модели учитывается степень связанности компонент.

<h3>Основная формула</h3>
В общем случае, эффективный упругий тензор для многокомпонентной горной породы рассчитыйвается по следующей формуле:<br>
<img src="https://github.com/Fedor4096/Rock-Physics-GSA/assets/108585151/ccb5643f-4778-4ffc-9793-9ea6bb81424a" height="120" vspace="10"><br>
<i>*В формуле необходимо использовать именно тензорные операции: умножение и поиск обратного тензора.</i><br><br>

В рамках данной работы реализован функционал только для <strong>духкомпонентного</strong> случая и отсутсвует возможность изменять <strong>ориентацию</strong> включений в пространстве (зафисированы горизонтально).<br><br>
Основная сложность расчёта заключается в поиске компонент тензора <strong>g</strong>, описывающих взаимодействие i-го включения горной породы с ближайшими включениями.<br>

<h3>Расчёт тензора g (вторая производная функции Грина)</h3>
Вычиление тензора <strong>g</strong> является сложным многоэтапным процессом.<br>
Необходимо использовать <strong>вспомогальный</strong> тензор <strong>a</strong> и применять <strong>численные методы</strong> инегрирования.<br><br>

Процесс расчёта <strong>g</strong> заключается в следующем:
<ol>
  <li>Вычисление компонент вспомогательного тензора <strong>a<sub>not sym</sub></strong>:</li>
  <img src="https://github.com/Fedor4096/Rock-Physics-GSA/assets/108585151/28cae17e-b819-4b26-b6e7-9835a0228764" height="70" vspace="30">, где
  <img src="https://github.com/Fedor4096/Rock-Physics-GSA/assets/108585151/9b73ac8d-7960-486d-b6f8-7c70dbb42666" height="50" vspace="30"> и
  <img src="https://github.com/Fedor4096/Rock-Physics-GSA/assets/108585151/439c47ed-bd82-44b9-8cc3-ba4297fa70ca" height="50" vspace="30">

  <li>Симметризация полученного тензора <strong>a<sub>not sym</sub></strong>:</li>
  <img src="https://github.com/Fedor4096/Rock-Physics-GSA/assets/108585151/5c555a87-96a5-4ef2-9012-bf419826c222" height="60" vspace="30">
  
  <li>Получение тензора <strong>g</strong> через переприсваивание компонент симметризованного <strong>a<sub>sym</sub></strong>:</li>
  <img src="https://github.com/Fedor4096/Rock-Physics-GSA/assets/108585151/bb17222f-aad9-421c-ae75-115152ba497f" height="70" vspace="30">
</ol>

<h3>Численное интегрирование</h3>
Для получения компонент вспомогательного нессиметризованного тензора <strong>a<sub>not sym</sub></strong><br>
необходимо вычислить интеграл по поверхности, заданной подынтегральной функцией.<br><br>

В данной работе для вычисления интеграла применялся метод с <strong>заранее заданными</strong> узлами интегрирования по следующей формуле:<br>
<img src="https://github.com/Fedor4096/Rock-Physics-GSA/assets/108585151/57fe586e-420c-4aee-8589-2204d0f499ae" height="70" vspace="30"><br><br>

Важно отметить, что правильный выбр узлов интегрирования представляет довольно сложную задачу, поскольку требует детального изучания поведения подынтегральных функций.



<h2>Практическая часть</h2>
Модель GSA относится к классу алгоритмов, для которых критически важна скорость расчёта.<br><br>
В связи с этим, в рамках данного проекта были проведены следующие работы:
<ul>
  <li><strong>На теоретичском уровне</strong> - выявлен наиболее оптимальный порядок вычисления переменных</li>
  <li><strong>На техническом уровне</strong> - использование методв JIT-компиляции с целью комплексной оптимизации программы</li>
</ul>

Наибольшее сокращение времени расчёта обеспечило именно применение JIT-компиляции. Таким образом, скорость вычислений сократилась в 3 раза.<br>

При этом нужно учитывать, что при при первом запуске алгоритма тратится значительное количество времени на компиляцию в машинный код требуемой программной логики.<br>

Однако, в большинстве случаев, алгоритм GSA используется последовательно и многоразово. В связи с этим, время, затрачиваемое <strong>исключительно</strong> на первой итерации расчёта на компиляцию функций в машинный код, при большом количестве итераций вносит незначительный вклад.<br>

Таким образом, использования языка Python в связке с JIT-компиляций в данном случае позволяет приблизиться к результатам, полученным на компилируемых языках, таких как Fortran, C или Rust. В отличие от стокового Python, который в среднем в 500 раз медленнее компилируемых аналогов, связка Python + JIT позволяет на первой итерации сократить разрыв до 150 раз, а на последующих - выполнять программу медленне уже в 40-50 раз.









